<!DOCTYPE html>

<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Trinkle vs AI</title>
  <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }


    html {
        background: #0b0c1a !important;
    }

    body,
    .game-container {
        background: linear-gradient(135deg, #0b0c1a, #1f2241) !important;
        background-attachment: fixed !important;
        font-family: 'Times New Roman', serif;
        height: 100vh;
        overflow: hidden;
        min-height: 100vh;
    }

    .game-container {
        width: 100vw;
        height: 100vh;
        position: relative;
    }

    .header {
        text-align: center;
        padding: 15px;
        color: white;
        position: relative;
    }

    .game-title {
        font-size: 2rem;
        font-weight: bold;
        width: 30%;
        margin: 0 auto;
        text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    }

    .buttons {
        position: absolute;
        top: 20px;
        left: 20px;
        display: flex;
        gap: 10px;
    }

    .game-button {
        padding: 10px 20px;
        background: rgba(255,255,255,0.9);
        border: 2px solid #8B4513;
        border-radius: 8px;
        font-family: 'Times New Roman', serif;
        font-size: 14px;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.3s ease;
        color: #8B4513;
    }

    .game-button:hover {
        background: rgba(255,255,255,1);
        transform: scale(1.05);
    }

    .game-area {
        position: absolute;
        top: 80px;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(255,255,255,0.1);
    }

    .point {
        position: absolute;
        width: 50px;
        height: 50px;
        cursor: pointer;
        z-index: 100;
        pointer-events: auto;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .point::before {
        content: '';
        width: 16px;
        height: 16px;
        background: #FFD700;
        border-radius: 50%;
        border: 2px solid #FFA500;
        box-shadow: 0 0 10px rgba(255, 215, 0, 0.6);
        transition: all 0.2s ease;
    }

    .point:hover::before {
        transform: scale(1.2);
        background: #FFFF00;
        box-shadow: 0 0 15px rgba(255, 255, 0, 0.8);
    }

    .point.selected::before {
        background: #FFFF00;
        transform: scale(1.3);
        border-color: #FF6347;
        box-shadow: 0 0 20px rgba(255, 255, 0, 1);
    }

    .line {
        position: absolute;
        height: 3px;
        transform-origin: left center;
        z-index: 5;
    }

    .triangle {
        position: absolute;
        font-size: 24px;
        font-weight: bold;
        z-index: 40;
        width: 30px;
        height: 30px;
        display: flex;
        align-items: center;
        justify-content: center;
        pointer-events: none;
    }

    .scoreboard {
        position: absolute;
        bottom: 20px;
        right: 20px;
        background: #0b0c1a;
        padding: 15px;
        min-width: 180px;
        font-family: 'Times New Roman', serif;
        color: #fffde7;
        border-radius: 10px;
        box-shadow: 0 0 15px rgba(255, 255, 255, 0.2);
        z-index: 50;
        pointer-events: auto;
    }

    .player-score {
        margin: 8px 0;
        font-size: 18px;
        font-weight: bold;
        font-style: italic;
    }

    .player1 { color: white; }
    .player2 { color: #FF6B6B; }

    .turn-indicator {
        font-size: 18px;
        animation: pulse 1s infinite;
    }

    .current-turn {
        text-align: center;
        margin-top: 10px;
        font-size: 16px;
        font-weight: bold;
        font-style: italic;
        padding: 5px;
        border-radius: 5px;
        background: rgba(255, 255, 255, 0.15);
        font-family: 'Times New Roman', serif;
        color: #fff;
    }

    .ai-thinking {
        background: rgba(255, 107, 107, 0.2) !important;
        animation: aiThinking 1.5s infinite;
    }

    /* Î∞òÏùëÌòï ÎîîÏûêÏù∏ */
    @media (max-width: 768px) {
        .game-title {
            font-size: 1.5rem;
            width: 50%;
        }
        
        .buttons {
            position: static;
            margin-bottom: 10px;
            justify-content: center;
        }
        
        .header {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
        }
        
        .scoreboard {
            bottom: 10px;
            right: 10px;
            min-width: 150px;
            padding: 10px;
            font-size: 14px;
        }
        
        .point {
            width: 60px;
            height: 60px;
        }
    }

    @media (min-width: 769px) {
        .game-area {
            top: 80px;
        }
    }

    @keyframes pulse {
        0%, 100% { transform: scale(1); }
        50% { transform: scale(1.2); }
    }

    @keyframes aiThinking {
        0%, 100% { opacity: 0.7; }
        50% { opacity: 1; }
    }

    @keyframes fadeInOut {
        0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
        20% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
    }
</style>


</head>
<body>
  <div class="game-container">
    <div class="header">
      <div class="buttons">
        <button class="game-button" onclick="restartGame()">Restart</button>
        <button class="game-button" onclick="goToIndex()">Index</button>
      </div>
      <h1 class="game-title">‚ú® TRI  TRINKY ‚ú®</h1>
    </div>

```
<div class="game-area" id="gameArea">
  <div class="scoreboard">
    <div class="player-score player1">
      <span id="player1Name">You</span>: <span id="score1">0</span> <span class="turn-indicator" id="turn1">‚≠ê</span>
    </div>
    <div class="player-score player2">
      <span id="player2Name">Trinky</span>: <span id="score2">0</span> <span class="turn-indicator" id="turn2" style="display:none;">ü§ñ</span>
    </div>
    <div class="current-turn" id="currentTurn">Your Turn</div>
  </div>
</div>
```

  </div>

<script>
    console.log("Ïä§ÌÅ¨Î¶ΩÌä∏ ÏãúÏûë");
    
    const gameArea = document.getElementById('gameArea');
    const scoreBoard = document.querySelector('.scoreboard');
    let points = [];
    let lines = [];
    let triangles = [];
    let currentPlayer = 1;
    let selectedPoint = null;
    let scores = { player1: 0, player2: 0 };
    let gameMode = 'ai';
    let isAiThinking = false;

    function createPoints() {
        console.log("Creating points");

        const areaRect = gameArea.getBoundingClientRect();
        const minDistance = Math.min(areaRect.width, areaRect.height) * 0.15;
        const margin = 60;
        const pointCount = 10; // 9Í∞úÏóêÏÑú 10Í∞úÎ°ú Î≥ÄÍ≤Ω

        // Í∏àÏßÄ Íµ¨Ïó≠ Ï†ïÏùò
        const forbiddenZones = [
            { x: 0, y: 0, width: 250, height: 100 },
            { x: areaRect.width - 250, y: areaRect.height - 180, width: 250, height: 180 }
        ];

        function isInForbiddenZone(x, y) {
            for (let zone of forbiddenZones) {
                if (x >= zone.x && x <= zone.x + zone.width && 
                    y >= zone.y && y <= zone.y + zone.height) {
                    return true;
                }
            }
            return false;
        }

        for (let i = 0; i < pointCount; i++) {
            let validPosition = false;
            let attempts = 0;
            let x, y;

            while (!validPosition && attempts < 100) {
                x = margin + Math.random() * (areaRect.width - 2 * margin);
                y = margin + Math.random() * (areaRect.height - 2 * margin);

                validPosition = true;
                
                if (isInForbiddenZone(x, y)) {
                    validPosition = false;
                    attempts++;
                    continue;
                }
                
                for (let existingPoint of points) {
                    const distance = Math.sqrt(Math.pow(x - existingPoint.x, 2) + Math.pow(y - existingPoint.y, 2));
                    if (distance < minDistance) {
                        validPosition = false;
                        break;
                    }
                }
                attempts++;
            }

            if (validPosition) {
                const point = document.createElement('div');
                point.className = 'point';
                point.style.left = (x - 25) + 'px';
                point.style.top = (y - 25) + 'px';
                
                point.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    if (!isAiThinking && currentPlayer === 1) {
                        selectPoint(i, x, y);
                    }
                });
                
                gameArea.appendChild(point);
                points.push({ x, y, element: point, id: i });
                console.log("Point created:", i, x, y);
            }
        }
        console.log("Total points:", points.length);
    }

    function selectPoint(pointId, x, y) {
        console.log("Point selected:", pointId);
        
        if (selectedPoint === null) {
            selectedPoint = { id: pointId, x, y };
            points[pointId].element.classList.add('selected');
        } else if (selectedPoint.id === pointId) {
            points[pointId].element.classList.remove('selected');
            selectedPoint = null;
        } else {
            drawLine(selectedPoint, { id: pointId, x, y });
            points[selectedPoint.id].element.classList.remove('selected');
            selectedPoint = null;
        }
    }

    function drawLine(point1, point2) {
        console.log("Drawing line:", point1.id, "->", point2.id);

        const existingLine = lines.find(line =>
            (line.point1 === point1.id && line.point2 === point2.id) ||
            (line.point1 === point2.id && line.point2 === point1.id)
        );

        if (existingLine) {
            console.log("Line already exists");
            return;
        }

        if (lineIntersectsExistingLines(point1, point2)) {
            console.log("Line intersects existing line or passes too close to a point");
            showWarningMessage("ÏÑ†Î∂ÑÏù¥ Îã§Î•∏ ÏÑ†Î∂ÑÍ≥º ÍµêÏ∞®ÌïòÍ±∞ÎÇò Ï†êÏùÑ ÏßÄÎÇòÍ∞à Ïàò ÏóÜÏäµÎãàÎã§!");
            return;
        }

        const line = document.createElement('div');
        line.className = 'line';

        const dx = point2.x - point1.x;
        const dy = point2.y - point1.y;
        const length = Math.sqrt(dx * dx + dy * dy);
        const angle = Math.atan2(dy, dx) * 180 / Math.PI;

        line.style.width = length + 'px';
        line.style.left = point1.x + 'px';
        line.style.top = (point1.y - 1.5) + 'px';
        line.style.transform = `rotate(${angle}deg)`;
        line.style.background = currentPlayer === 1 ? 'white' : '#FF6B6B';

        gameArea.appendChild(line);
        lines.push({
            point1: point1.id,
            point2: point2.id,
            player: currentPlayer,
            element: line
        });

        const newTriangles = checkForAllTriangles(point1.id, point2.id);
        if (newTriangles.length > 0) {
            console.log(`üî∫ ÏÇºÍ∞ÅÌòï ${newTriangles.length}Í∞ú ÏôÑÏÑ±! ÌîåÎ†àÏù¥Ïñ¥ ${currentPlayer} Í≥ÑÏÜç ÏßÑÌñâ`);
            newTriangles.forEach(triangle => createTriangle(triangle));
            scores[`player${currentPlayer}`] += newTriangles.length;
            updateScoreboard();
            // ÏÇºÍ∞ÅÌòïÏùÑ ÏôÑÏÑ±ÌñàÏúºÎØÄÎ°ú Í∞ôÏùÄ ÌîåÎ†àÏù¥Ïñ¥Í∞Ä Í≥ÑÏÜç ÏßÑÌñâ
            updateTurnDisplay();
        } else {
            console.log(`‚û°Ô∏è ÏÇºÍ∞ÅÌòï ÏóÜÏùå. ÌÑ¥ ÍµêÏ≤¥: ${currentPlayer} -> ${currentPlayer === 1 ? 2 : 1}`);
            // ÏÇºÍ∞ÅÌòïÏùÑ ÏôÑÏÑ±ÌïòÏßÄ Î™ªÌñàÏúºÎØÄÎ°ú ÌÑ¥ ÍµêÏ≤¥
            currentPlayer = currentPlayer === 1 ? 2 : 1;
            updateTurnDisplay();
        }

        // AI ÌÑ¥Ïù∏ Í≤ΩÏö∞ ÏûêÎèôÏúºÎ°ú ÏàòÌñâ
        if (currentPlayer === 2 && !isAiThinking) {
            console.log("ü§ñ AI ÌÑ¥ Í∞êÏßÄ - makeAiMove Ìò∏Ï∂ú");
            // Í≤åÏûÑÏù¥ ÎÅùÎÇ¨ÎäîÏßÄ Î®ºÏ†Ä ÌôïÏù∏
            if (isGameOver()) {
                console.log("üèÅ Í≤åÏûÑ Ï¢ÖÎ£å!");
                showGameEndMessage();
            } else {
                setTimeout(makeAiMove, 1000);
            }
        } else if (currentPlayer === 1 && isGameOver()) {
            console.log("üèÅ Í≤åÏûÑ Ï¢ÖÎ£å!");
            showGameEndMessage();
        }
    }

    function makeAiMove() {
        if (isAiThinking || currentPlayer !== 2) return;

        isAiThinking = true;
        updateTurnDisplay();

        console.log("ü§ñ AIÍ∞Ä ÏÉùÍ∞Å Ï§ë...");

        const thinkingTime = 800 + Math.random() * 700;

        setTimeout(() => {
            const bestMove = findBestAiMoveAdvanced();
            
            if (bestMove) {
                console.log("üéØ AIÍ∞Ä ÏÑ†ÌÉùÌïú Ïàò:", bestMove);
                
                const point1 = points[bestMove.point1];
                const point2 = points[bestMove.point2];
                
                point1.element.classList.add('selected');
                point2.element.classList.add('selected');
                
                setTimeout(() => {
                    point1.element.classList.remove('selected');
                    point2.element.classList.remove('selected');
                    
                    drawLine(
                        { id: bestMove.point1, x: point1.x, y: point1.y },
                        { id: bestMove.point2, x: point2.x, y: point2.y }
                    );
                    
                    isAiThinking = false;
                    updateTurnDisplay();
                    
                    // ÏÇºÍ∞ÅÌòï ÏôÑÏÑ± ÌõÑ AIÍ∞Ä Í≥ÑÏÜç ÌÑ¥ÏùÑ Í∞ÄÏßÄÎäîÏßÄ ÌôïÏù∏
                    console.log("üîÑ AI Ïàò ÏôÑÎ£å ÌõÑ - currentPlayer:", currentPlayer, "isAiThinking:", isAiThinking);
                    
                    // AIÍ∞Ä Í≥ÑÏÜç ÌÑ¥ÏùÑ Í∞ÄÏßÑÎã§Î©¥ Îã§Ïãú ÏàòÌñâ (Îã®, Í≤åÏûÑÏù¥ ÎÅùÎÇòÏßÄ ÏïäÏïòÎã§Î©¥)
                    if (currentPlayer === 2 && !isAiThinking && !isGameOver()) {
                        console.log("üéØ AI Ïó∞ÏÜç ÌÑ¥ ÏãúÏûë!");
                        setTimeout(makeAiMove, 800);
                    } else if (isGameOver()) {
                        console.log("üèÅ AI Ïàò ÌõÑ Í≤åÏûÑ Ï¢ÖÎ£å!");
                        showGameEndMessage();
                    }
                }, 500);
            } else {
                isAiThinking = false;
                updateTurnDisplay();
                console.log("‚ùå AIÏóêÍ≤å Ïú†Ìö®Ìïú ÏàòÍ∞Ä ÏóÜÏùå - Í≤åÏûÑ Ï¢ÖÎ£å Ï≤¥ÌÅ¨");
                if (isGameOver()) {
                    showGameEndMessage();
                }
            }
        }, thinkingTime);
    }

    // ÎòëÎòëÌïú AI Ï†ÑÎûµ Ìï®Ïàò
    function findBestAiMoveAdvanced() {
        const possibleMoves = getAllValidMoves();

        if (possibleMoves.length === 0) {
            console.log("‚ö†Ô∏è Í∞ÄÎä•Ìïú ÏàòÍ∞Ä ÏóÜÏùå");
            return null;
        }

        console.log(`üîç Ï¥ù ${possibleMoves.length}Í∞úÏùò Í∞ÄÎä•Ìïú Ïàò Î∂ÑÏÑù Ï§ë...`);

        // 1Îã®Í≥Ñ: ÏÇºÍ∞ÅÌòï ÏôÑÏÑ± Ïö∞ÏÑ† (Ïù¥ÎØ∏ Ïó∞Í≤∞Îêú Îëê Ï†êÎÅºÎ¶¨ Ïó∞Í≤∞)
        const triangleCompletingMoves = findTriangleCompletingMoves(possibleMoves);
        if (triangleCompletingMoves.length > 0) {
            console.log("üéØ ÏÇºÍ∞ÅÌòï ÏôÑÏÑ± Í∞ÄÎä•!");
            return selectBestFromMoves(triangleCompletingMoves, "triangle");
        }

        // 2Îã®Í≥Ñ: ÏÉàÎ°úÏö¥ ÏãúÏûë (ÏïÑÎ¨¥Í≤ÉÎèÑ Ïó∞Í≤∞ Ïïà Îêú Îëê Ï†ê)
        const isolatedMoves = findIsolatedPointMoves(possibleMoves);

        // 3Îã®Í≥Ñ: ÌôïÏû• (ÌïúÏ™ΩÎßå Ïó∞Í≤∞Îêú Ï†êÍ≥º Ïïà Ïó∞Í≤∞Îêú Ï†ê)
        const extensionMoves = findExtensionMoves(possibleMoves);

        // Ïö∞ÏÑ†ÏàúÏúÑÏóê Îî∞Îùº ÏÑ†ÌÉù
        let candidateMoves = [];

        if (isolatedMoves.length > 0) {
            candidateMoves = isolatedMoves;
            console.log(`üÜï ÏÉàÎ°úÏö¥ ÏãúÏûë Í∞ÄÎä•: ${isolatedMoves.length}Í∞ú`);
        } else if (extensionMoves.length > 0) {
            candidateMoves = extensionMoves;
            console.log(`üîó ÌôïÏû• Í∞ÄÎä•: ${extensionMoves.length}Í∞ú`);
        } else {
            candidateMoves = possibleMoves;
            console.log(`‚ö° Î™®Îì† Í∞ÄÎä•Ìïú Ïàò Í≥†Î†§: ${possibleMoves.length}Í∞ú`);
        }

        return selectBestFromMoves(candidateMoves, "strategic");
    }

    // Î™®Îì† Ïú†Ìö®Ìïú ÏàòÎ•º Ï∞æÎäî Ìï®Ïàò
    function getAllValidMoves() {
        const moves = [];

        for (let i = 0; i < points.length; i++) {
            for (let j = i + 1; j < points.length; j++) {
                const existingLine = lines.find(line =>
                    (line.point1 === i && line.point2 === j) ||
                    (line.point1 === j && line.point2 === i)
                );
                
                if (!existingLine) {
                    const point1 = { id: i, x: points[i].x, y: points[i].y };
                    const point2 = { id: j, x: points[j].x, y: points[j].y };
                    
                    if (!lineIntersectsExistingLines(point1, point2)) {
                        moves.push({ point1: i, point2: j });
                    }
                }
            }
        }

        return moves;
    }

    // ÏÇºÍ∞ÅÌòïÏùÑ ÏôÑÏÑ±Ìï† Ïàò ÏûàÎäî Ïàò Ï∞æÍ∏∞
    function findTriangleCompletingMoves(possibleMoves) {
        const triangleMoves = [];

        for (let move of possibleMoves) {
            const point1Connections = getPointConnections(move.point1);
            const point2Connections = getPointConnections(move.point2);
            
            if (point1Connections.length > 0 && point2Connections.length > 0) {
                const trianglesFormed = simulateTrianglesFormed(move.point1, move.point2);
                if (trianglesFormed.length > 0) {
                    triangleMoves.push({
                        ...move,
                        triangleCount: trianglesFormed.length,
                        priority: 1
                    });
                }
            }
        }

        return triangleMoves.sort((a, b) => b.triangleCount - a.triangleCount);
    }

    // ÏÇºÍ∞ÅÌòï ÌòïÏÑ± ÏãúÎÆ¨Î†àÏù¥ÏÖò
    function simulateTrianglesFormed(point1Id, point2Id) {
        const completedTriangles = [];
        
        for (let point of points) {
            if (point.id === point1Id || point.id === point2Id) continue;
            
            const hasLine1 = lines.some(line => 
                (line.point1 === point1Id && line.point2 === point.id) ||
                (line.point1 === point.id && line.point2 === point1Id)
            );
            
            const hasLine2 = lines.some(line => 
                (line.point1 === point2Id && line.point2 === point.id) ||
                (line.point1 === point.id && line.point2 === point2Id)
            );

            if (hasLine1 && hasLine2) {
                const triangle = [point1Id, point2Id, point.id].sort((a, b) => a - b);
                completedTriangles.push(triangle);
            }
        }
        
        return completedTriangles;
    }

    // ÏïÑÎ¨¥Í≤ÉÎèÑ Ïó∞Í≤∞ÎêòÏßÄ ÏïäÏùÄ Îëê Ï†êÎÅºÎ¶¨ Ïó∞Í≤∞ÌïòÎäî Ïàò Ï∞æÍ∏∞
    function findIsolatedPointMoves(possibleMoves) {
        const isolatedMoves = [];

        for (let move of possibleMoves) {
            const point1Connections = getPointConnections(move.point1);
            const point2Connections = getPointConnections(move.point2);
            
            if (point1Connections.length === 0 && point2Connections.length === 0) {
                isolatedMoves.push({
                    ...move,
                    priority: 2
                });
            }
        }

        return isolatedMoves;
    }

    // ÌïúÏ™ΩÎßå Ïó∞Í≤∞Îêú Ï†êÍ≥º Ïïà Ïó∞Í≤∞Îêú Ï†êÏùÑ Ïó∞Í≤∞ÌïòÎäî Ïàò Ï∞æÍ∏∞  
    function findExtensionMoves(possibleMoves) {
        const extensionMoves = [];

        for (let move of possibleMoves) {
            const point1Connections = getPointConnections(move.point1);
            const point2Connections = getPointConnections(move.point2);
            
            if ((point1Connections.length > 0 && point2Connections.length === 0) ||
                (point1Connections.length === 0 && point2Connections.length > 0)) {
                extensionMoves.push({
                    ...move,
                    priority: 3
                });
            }
        }

        return extensionMoves;
    }

    // Ï†êÏùò Ïó∞Í≤∞ ÏÉÅÌÉú ÌôïÏù∏
    function getPointConnections(pointId) {
        return lines.filter(line =>
            line.point1 === pointId || line.point2 === pointId
        );
    }

    // ÌõÑÎ≥¥ ÏàòÎì§ Ï§ëÏóêÏÑú ÏµúÏ†ÅÏùò Ïàò ÏÑ†ÌÉù
    function selectBestFromMoves(moves, type) {
        if (moves.length === 0) return null;

        if (type === "triangle") {
            return moves[0]; // Ïù¥ÎØ∏ Ï†ïÎ†¨ÎêòÏñ¥ ÏûàÏùå
        }

        const scoredMoves = moves.map(move => ({
            ...move,
            strategicScore: calculateStrategicScore(move)
        }));

        scoredMoves.sort((a, b) => b.strategicScore - a.strategicScore);

        const topMoves = scoredMoves.slice(0, Math.min(3, scoredMoves.length));
        const selectedMove = topMoves[Math.floor(Math.random() * topMoves.length)];

        console.log(`üé≤ Ï†ÑÎûµÏ†Å Ï†êÏàò: ${selectedMove.strategicScore.toFixed(1)}`);
        return selectedMove;
    }

    // Ï†ÑÎûµÏ†Å Ï†êÏàò Í≥ÑÏÇ∞
    function calculateStrategicScore(move) {
        let score = 0;

        const centerX = gameArea.offsetWidth / 2;
        const centerY = gameArea.offsetHeight / 2;

        const point1 = points[move.point1];
        const point2 = points[move.point2];

        const dist1 = Math.sqrt(Math.pow(point1.x - centerX, 2) + Math.pow(point1.y - centerY, 2));
        const dist2 = Math.sqrt(Math.pow(point2.x - centerY, 2) + Math.pow(point2.y - centerY, 2));

        score += (500 - dist1 * 0.5) + (500 - dist2 * 0.5);

        const connections1 = getPointConnections(move.point1).length;
        const connections2 = getPointConnections(move.point2).length;

        score += (connections1 + connections2) * 30;

        score += evaluateFutureTrianglePotential(move.point1, move.point2) * 20;

        return score;
    }

    // ÎØ∏Îûò ÏÇºÍ∞ÅÌòï Í∞ÄÎä•ÏÑ± ÌèâÍ∞Ä
    function evaluateFutureTrianglePotential(point1Id, point2Id) {
        let potential = 0;

        for (let i = 0; i < points.length; i++) {
            if (i === point1Id || i === point2Id) continue;
            
            const canConnect1 = canConnectPoints(point1Id, i);
            const canConnect2 = canConnectPoints(point2Id, i);
            
            if (canConnect1 && canConnect2) {
                potential += 1;
            }
        }

        return potential;
    }

    // Îëê Ï†êÏù¥ Ïó∞Í≤∞ Í∞ÄÎä•ÌïúÏßÄ ÌôïÏù∏
    function canConnectPoints(pointId1, pointId2) {
        const existingLine = lines.find(line =>
            (line.point1 === pointId1 && line.point2 === pointId2) ||
            (line.point1 === pointId2 && line.point2 === pointId1)
        );

        if (existingLine) return false;

        const point1 = { id: pointId1, x: points[pointId1].x, y: points[pointId1].y };
        const point2 = { id: pointId2, x: points[pointId2].x, y: points[pointId2].y };

        return !lineIntersectsExistingLines(point1, point2);
    }

    function lineIntersectsExistingLines(newPoint1, newPoint2) {
        // 1. Í∏∞Ï°¥ ÏÑ†Î∂ÑÎì§Í≥ºÏùò ÍµêÏ∞® Ï≤¥ÌÅ¨
        for (let existingLine of lines) {
            const existingP1 = points[existingLine.point1];
            const existingP2 = points[existingLine.point2];
            
            if (newPoint1.id === existingLine.point1 || newPoint1.id === existingLine.point2 ||
                newPoint2.id === existingLine.point1 || newPoint2.id === existingLine.point2) {
                continue;
            }
            
            if (doLinesIntersect(
                newPoint1.x, newPoint1.y, newPoint2.x, newPoint2.y,
                existingP1.x, existingP1.y, existingP2.x, existingP2.y
            )) {
                return true;
            }
        }
        
        // 2. Îã§Î•∏ Ï†êÎì§ÏùÑ ÎÑàÎ¨¥ Í∞ÄÍπùÍ≤å ÏßÄÎÇòÍ∞ÄÎäîÏßÄ Ï≤¥ÌÅ¨
        for (let point of points) {
            // ÏÑ†Î∂ÑÏùò Ïñë ÎÅùÏ†êÏùÄ Ï†úÏô∏
            if (point.id === newPoint1.id || point.id === newPoint2.id) {
                continue;
            }
            
            const distance = distanceFromPointToLine(
                point.x, point.y,
                newPoint1.x, newPoint1.y, newPoint2.x, newPoint2.y
            );
            
            // Ï†ê Î∞òÏßÄÎ¶Ñ(25px) Ï†ïÎèÑÏùò ÏïàÏ†Ñ Í±∞Î¶¨ ÌôïÎ≥¥
            if (distance < 25) {
                console.log(`‚ö†Ô∏è ÏÑ†Î∂ÑÏù¥ Ï†ê ${point.id}Î•º ÎÑàÎ¨¥ Í∞ÄÍπùÍ≤å ÏßÄÎÇòÍ∞ê (Í±∞Î¶¨: ${distance.toFixed(1)}px)`);
                return true;
            }
        }
        
        return false;
    }

    // Ï†êÍ≥º ÏÑ†Î∂Ñ ÏÇ¨Ïù¥Ïùò ÏµúÎã® Í±∞Î¶¨ Í≥ÑÏÇ∞
    function distanceFromPointToLine(px, py, x1, y1, x2, y2) {
        // ÏÑ†Î∂ÑÏùò Í∏∏Ïù¥Ïùò Ï†úÍ≥±
        const lineLength = Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2);
        
        if (lineLength === 0) {
            // ÏÑ†Î∂ÑÏù¥ Ï†êÏù∏ Í≤ΩÏö∞
            return Math.sqrt(Math.pow(px - x1, 2) + Math.pow(py - y1, 2));
        }
        
        // Ï†êÏóêÏÑú ÏÑ†Î∂ÑÏúºÎ°úÏùò ÏàòÏßÅÏÑ†Ïùò ÏúÑÏπò Í≥ÑÏÇ∞ (0~1 ÏÇ¨Ïù¥)
        const t = Math.max(0, Math.min(1, ((px - x1) * (x2 - x1) + (py - y1) * (y2 - y1)) / lineLength));
        
        // ÏÑ†Î∂Ñ ÏúÑÏùò Í∞ÄÏû• Í∞ÄÍπåÏö¥ Ï†ê
        const closestX = x1 + t * (x2 - x1);
        const closestY = y1 + t * (y2 - y1);
        
        // Ï†êÍ≥º Í∞ÄÏû• Í∞ÄÍπåÏö¥ Ï†ê ÏÇ¨Ïù¥Ïùò Í±∞Î¶¨
        return Math.sqrt(Math.pow(px - closestX, 2) + Math.pow(py - closestY, 2));
    }

    function doLinesIntersect(x1, y1, x2, y2, x3, y3, x4, y4) {
        const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
        
        if (Math.abs(denom) < 1e-10) {
            return false;
        }
        
        const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
        const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom;
        
        return t > 0 && t < 1 && u > 0 && u < 1;
    }

    function showWarningMessage(message) {
        const warning = document.createElement('div');
        warning.textContent = message;
        warning.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 0, 0, 0.9);
            color: white;
            padding: 15px 25px;
            border-radius: 10px;
            font-size: 18px;
            z-index: 1000;
        `;
        document.body.appendChild(warning);
        setTimeout(() => warning.remove(), 2000);
    }

    function checkForAllTriangles(newPoint1, newPoint2) {
        const completedTriangles = [];
        
        console.log(`üîç ÏÇºÍ∞ÅÌòï Ï≤¥ÌÅ¨: ÏÉàÎ°ú Í∑∏ÏùÄ ÏÑ† ${newPoint1}-${newPoint2}`);
        console.log(`üìä ÌòÑÏû¨ Ï¥ù ÏÑ†Ïùò Í∞úÏàò: ${lines.length}`);
        
        for (let point of points) {
            if (point.id === newPoint1 || point.id === newPoint2) continue;
            
            // Ï≤´ Î≤àÏß∏ ÏÑ†: newPoint1 ‚Üî point.id
            const hasLine1 = lines.some(line => 
                (line.point1 === newPoint1 && line.point2 === point.id) ||
                (line.point1 === point.id && line.point2 === newPoint1)
            );
            
            // Îëê Î≤àÏß∏ ÏÑ†: newPoint2 ‚Üî point.id  
            const hasLine2 = lines.some(line => 
                (line.point1 === newPoint2 && line.point2 === point.id) ||
                (line.point1 === point.id && line.point2 === newPoint2)
            );

            if (hasLine1 && hasLine2) {
                const triangle = [newPoint1, newPoint2, point.id].sort((a, b) => a - b);
                
                // Ïù¥ÎØ∏ Ï°¥Ïû¨ÌïòÎäî ÏÇºÍ∞ÅÌòïÏù∏ÏßÄ ÌôïÏù∏
                const triangleExists = triangles.some(existingTriangle => {
                    const existingPoints = existingTriangle.points.slice().sort((a, b) => a - b);
                    return JSON.stringify(triangle) === JSON.stringify(existingPoints);
                });
                
                if (!triangleExists) {
                    console.log(`‚úÖ ÏßÑÏßú ÏÇºÍ∞ÅÌòï ÏôÑÏÑ±: ${triangle.join('-')}`);
                    console.log(`   ÏÑ†1: ${newPoint1}-${point.id} Ï°¥Ïû¨: ${hasLine1}`);
                    console.log(`   ÏÑ†2: ${newPoint2}-${point.id} Ï°¥Ïû¨: ${hasLine2}`);
                    console.log(`   ÏÑ†3: ${newPoint1}-${newPoint2} ÏÉàÎ°ú Í∑∏Ïùå`);
                    completedTriangles.push(triangle);
                } else {
                    console.log(`‚ùå Ïù¥ÎØ∏ Ï°¥Ïû¨ÌïòÎäî ÏÇºÍ∞ÅÌòï: ${triangle.join('-')}`);
                }
            }
        }
        
        if (completedTriangles.length === 0) {
            console.log(`‚ùå ÏÇºÍ∞ÅÌòï ÏóÜÏùå - ÏÇ¨Í∞ÅÌòïÏù¥ÎÇò Îã§Î•∏ ÎèÑÌòïÏùº Ïàò ÏûàÏùå`);
        }
        
        console.log(`üîç ÏµúÏ¢Ö ÏÇºÍ∞ÅÌòï Ï≤¥ÌÅ¨ Í≤∞Í≥º: ${completedTriangles.length}Í∞ú Î∞úÍ≤¨`);
        return completedTriangles;
    }

    function createTriangle(trianglePoints) {
        const p1 = points[trianglePoints[0]];
        const p2 = points[trianglePoints[1]];
        const p3 = points[trianglePoints[2]];

        const centerX = (p1.x + p2.x + p3.x) / 3;
        const centerY = (p1.y + p2.y + p3.y) / 3;

        const triangle = document.createElement('div');
        triangle.className = 'triangle';
        triangle.style.left = (centerX - 15) + 'px';
        triangle.style.top = (centerY - 15) + 'px';
        triangle.style.color = currentPlayer === 1 ? 'white' : '#FF6B6B';
        triangle.textContent = currentPlayer === 1 ? 'V' : 'O';

        gameArea.appendChild(triangle);
        triangles.push({ points: trianglePoints, player: currentPlayer, element: triangle });
    }

    function updateTurnDisplay() {
        const turnText = currentPlayer === 1 ? 'Your Turn' : 'Trinky is thinking...';
        document.getElementById('currentTurn').textContent = turnText;
        document.getElementById('currentTurn').style.color = currentPlayer === 1 ? 'white' : '#FF6B6B';
        
        if (isAiThinking) {
            document.getElementById('currentTurn').classList.add('ai-thinking');
        } else {
            document.getElementById('currentTurn').classList.remove('ai-thinking');
        }
        
        document.getElementById('turn1').style.display = currentPlayer === 1 ? 'inline' : 'none';
        document.getElementById('turn2').style.display = currentPlayer === 2 ? 'inline' : 'none';
    }

    function updateScoreboard() {
        document.getElementById('score1').textContent = scores.player1;
        document.getElementById('score2').textContent = scores.player2;
    }

    function isGameOver() {
        return getAllValidMoves().length === 0;
    }

    function showGameEndMessage() {
        isAiThinking = false;
        const winner = scores.player1 > scores.player2 ? "You Win! üéâ" : 
                      scores.player2 > scores.player1 ? "Trinky Wins! ü§ñ" : "Draw! ü§ù";
        
        document.getElementById('currentTurn').textContent = `Game Over - ${winner}`;
        document.getElementById('currentTurn').style.background = 'rgba(0, 255, 0, 0.3)';
        
        setTimeout(() => {
            alert(`Í≤åÏûÑ Ï¢ÖÎ£å!\n${winner}\n\nYour Score: ${scores.player1}\nTrinky Score: ${scores.player2}`);
        }, 500);
    }

    function restartGame() {
        points.forEach(point => point.element.remove());
        lines.forEach(line => line.element.remove());
        triangles.forEach(triangle => triangle.element.remove());
        
        points = [];
        lines = [];
        triangles = [];
        currentPlayer = 1;
        selectedPoint = null;
        scores = { player1: 0, player2: 0 };
        isAiThinking = false;
        
        updateScoreboard();
        updateTurnDisplay();
        setTimeout(createPoints, 100);
    }

    function goToIndex() {
        alert("Going to index page");
    }

    window.addEventListener('load', function() {
        setTimeout(createPoints, 100);
        updateTurnDisplay();
    });
</script>

</body>
</html>
